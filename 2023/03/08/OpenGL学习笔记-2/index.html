<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="你好,三角形(一)">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenGL学习笔记-2">
<meta property="og:url" content="http://leingbai.github.io/2023/03/08/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/index.html">
<meta property="og:site_name" content="LeingBai&#39;s Blog">
<meta property="og:description" content="你好,三角形(一)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-08T13:27:58.000Z">
<meta property="article:modified_time" content="2023-03-21T18:26:14.037Z">
<meta property="article:author" content="LeingBai">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://LeingBai.github.io/2023/03/08/OpenGL学习笔记-2/"/>





  <title>OpenGL学习笔记-2 | LeingBai's Blog</title>
  








<meta name="generator" content="Hexo 6.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LeingBai's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">LeingBai's Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://LeingBai.github.io/2023/03/08/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeingBai's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OpenGL学习笔记-2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-03-08T21:27:58+08:00">
                2023-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>你好,三角形(一)</p>
<span id="more"></span>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>顶点数组对象:Vertex Array Object,VAO</p>
<p>顶点缓冲对象:Vertex Buffer Object,VBO</p>
<p>元素缓冲对象:Element BUffer Object,EBO 也叫 索引缓冲对象 Index Buffer Object，IBO</p>
<h2 id="一-图形渲染管线-Graphics-Pipeline"><a href="#一-图形渲染管线-Graphics-Pipeline" class="headerlink" title="一.图形渲染管线(Graphics Pipeline)"></a>一.图形渲染管线(Graphics Pipeline)</h2><p>在OpenGL中,空间是以三维的形式存在的,但是我们日常使用的屏幕是一块平面,这导致了OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素.</p>
<p>图形渲染管线实质上是把一堆原始图像数据途径一个输送管道,期间经过各种变化和处理最终出现在屏幕上.它可以被笼统的分为两个部分,第一部分是把3D坐标转换为2D坐标,第二部分是把2D坐标转变为实际的有颜色的像素.</p>
<p>图形渲染管线的每个阶段:顶点着色器-&gt;图元装配-&gt;几何着色器-&gt;光栅化-&gt;片段着色器-&gt;测试与混合</p>
<p>其中每个阶段的输出都是写一个阶段的输入.</p>
<p>图形渲染管线的具体介绍如下:</p>
<h3 id="零-顶点数据"><a href="#零-顶点数据" class="headerlink" title="零.顶点数据"></a>零.顶点数据</h3><p>我们用一个数组来传递3个3d坐标作为管线的初始输入,这表示了一个三角形,这个数组就叫做顶点数据(Vertex Data),顶点数据是一系列顶点的集合.</p>
<p>一个顶点(Vertex)是一个3D坐标的数据的集合,而顶点数据是用顶点属性(Vertex Attribute)来表示的,它可以包含任何我们想用的数据.</p>
<h3 id="一-顶点着色器-Vertex-Shader"><a href="#一-顶点着色器-Vertex-Shader" class="headerlink" title="一.顶点着色器(Vertex Shader)"></a>一.顶点着色器(Vertex Shader)</h3><p>图形渲染管线的第一个部分叫做顶点着色器,他的输入是一个单独的顶点,他的任务是把3D坐标转换为另一种3D坐标,同时会对顶点属性做一些基本处理</p>
<h3 id="二-图元装配-Primitive-Assembly"><a href="#二-图元装配-Primitive-Assembly" class="headerlink" title="二.图元装配(Primitive Assembly)"></a>二.图元装配(Primitive Assembly)</h3><p>会把顶点着色器输出的所有顶点作为输入,装配为指定图元的形状,例如一个三角形.</p>
<h3 id="三-几何着色器"><a href="#三-几何着色器" class="headerlink" title="三.几何着色器"></a>三.几何着色器</h3><p>几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。</p>
<h3 id="四-光栅化阶段"><a href="#四-光栅化阶段" class="headerlink" title="四.光栅化阶段"></a>四.光栅化阶段</h3><p>这里把图元映射为最终屏幕上相应的像素,生成为片段着色器使用的片段(Fragment),他会在片段着色器运行之前执行裁切,裁切会丢弃你的视图以外的所有像素.</p>
<blockquote>
<p>OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</p>
</blockquote>
<h3 id="五-片段着色器"><a href="#五-片段着色器" class="headerlink" title="五.片段着色器"></a>五.片段着色器</h3><p>片段着色器的目的是计算一个像素点最终颜色,通常,片段着色器包含3D场景的数据,比如光照,阴影,光的颜色等等.</p>
<h3 id="六-测试与混合阶段"><a href="#六-测试与混合阶段" class="headerlink" title="六.测试与混合阶段"></a>六.测试与混合阶段</h3><p>这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p>
<h2 id="二-顶点着色器（输入顶点）"><a href="#二-顶点着色器（输入顶点）" class="headerlink" title="二.顶点着色器（输入顶点）"></a>二.顶点着色器（输入顶点）</h2><p>我们在OpenGL中定义的3D坐标(x,y,z),只有当他们在区间(-1.0,1.0)这个范围内才会被处理,这个范围叫做标准化设备坐标(Normalized Device Coordinates).</p>
<p>z轴上的坐标叫做深度,它代表一个像素在空间中与你的距离,深度高的像素会被深度低的像素遮挡.</p>
<p>这里我们渲染一个三角形,我们一共要指定三个顶点,每个顶点都有一个3D位置,定义一个float数组,来表示它.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之后我们把这个数组发送给顶点着色器,它会在GPU中创建内存来存储我们的顶点数据.</p>
<blockquote>
<p>同时配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
</blockquote>
<p>为了管理这个内存,我们使用一个对象,叫做顶点缓冲对象(Vertext Buffer Objects),他会在显存中存储大量的顶点,这样我们就可以一次性的发送一大批数据到显卡上,而不是每个顶点发送一次.</p>
<p>OpenGL中有许多对象,他们都有一个独一无二的id,所以我们可以使用glGenBuffers函数和一个缓冲ID来生成一个VBO.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VBO;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>,&amp;VBO);<span class="comment">//把VBO的引用绑定到ID:1上</span></span><br></pre></td></tr></table></figure>
<p>OpenGL有很多缓冲对象类型,顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER,OpenGL允许我们同时绑定多个缓冲,只要他们是不同的缓冲类型,我们可以使用glBindBuffer函数,把新创建的缓冲绑定到缓冲类型GL_ARRAY_BUFFER目标上:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER,VBO);</span><br></pre></td></tr></table></figure>
<p>之后,我们使用的任何缓冲调用,在GL_ARRAY_BUFFER目标上,都会用来配置当前绑定缓冲,即VBO,然后我们可以调用glBufferdata函数,他会把之前定义的顶点数据复制到缓冲中.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>这个函数是一个专门把用户定义的数据复制到当前绑定缓冲的函数</p>
<p>它的第一个参数是目标缓冲的类型(GL_ARRAY_BUFFER)</p>
<p>第二个参数是指定传输数据的大小(以字节为单位),用sizeof计算即可.</p>
<p>第三个参数是我们实际发送的数据</p>
<p>第四个参数是指定了我们希望显卡管理给定数据的方式:</p>
<ul>
<li>GL_STATIC_DRAW ：数据不会或几乎不会改变。</li>
<li>GL_DYNAMIC_DRAW：数据会被改变很多。</li>
<li>GL_STREAM_DRAW ：数据每次绘制时都会改变。</li>
</ul>
<p>这样是为了确保显卡把数据放入显存中可以高速写入的部分.</p>
<h3 id="创建顶点着色器"><a href="#创建顶点着色器" class="headerlink" title="创建顶点着色器"></a>创建顶点着色器</h3><p>顶点着色器是一个可编程着色器,在使用现代OpenGL进行着色的时候,我们至少需要设置一个顶点和一个片段着色器.</p>
<p>使用着色器语言GLSL(OpenGL Shading Language)来编写顶点着色器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#verson 330 core</span></span><br><span class="line">layout(location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着色器起始于一个版本的声明,glsl的版本号和opengl的版本号是一一对应的.</p>
<p>下一步是使用in关键词,在顶点着色器中声明所有的输入顶点属性(Input Vertex Attribute),由于我们现在只需要一个顶点属性,即位置.所以我们只需要声明一个向量vec3.3代表这个向量有三个分量(float),这对应了我们位置的三个坐标. 我们这个vec3变量去名字叫做aPos.</p>
<p>我们也用了layout(location &#x3D; 0)设定输入变量的位置值.</p>
<blockquote>
<p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在GLSL中一个向量有最多4个分量，每个分量值都代表空间中的一个坐标，它们可以通过vec.x、vec.y、vec.z和vec.w来获取。注意vec.w分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓透视除法(Perspective Division)上。我们会在后面的教程中更详细地讨论向量。</p>
</blockquote>
<p>对于这个着色器的内容,我们将位置数据(aPos)赋给预定义的gl_Position,当然,gl_Position是一个vec4,所以赋值的时候第四个参数我们使用1.0f.</p>
<p>所以这个非常简单的着色器做的事情包括,定义aPos,类型为vec,将aPos的x,y,z和1.0赋值给预定义的gl_Position.</p>
<h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><p>我们先使用一个字符串来硬编码着色器.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *vertexShaderSource = <span class="string">&quot;#version 330 core\n&quot;</span></span><br><span class="line">    <span class="string">&quot;layout (location = 0) in vec3 aPos;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;void main()\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#123;\n&quot;</span></span><br><span class="line">    <span class="string">&quot;   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n&quot;</span></span><br><span class="line">    <span class="string">&quot;&#125;\0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>为了在OpenGL中使用它,我们需要在OpenGL中使用一个ID来引用着色器.这个ID我们用int类型,用glCreateShader的返回值来赋值.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> vrtexShader;</span><br><span class="line">vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure>

<p>下一步,我们把着色源码,附加到着色器对象上,然后对他编译</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//这个函数把要编译的着色器对象作为第一个参数</span></span><br><span class="line"><span class="comment">//第二个参数，是传递的字符串的数量</span></span><br><span class="line"><span class="comment">//第三个是真的的源码,我们之前创建了一个char*这里使用它的地址作为参数。</span></span><br><span class="line"><span class="comment">//第四个先设置为NULL</span></span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);</span><br><span class="line"><span class="comment">//编译着色器，参数是一个着色器对象。</span></span><br></pre></td></tr></table></figure>

<h2 id="片段着色器（Fragment-Shader）"><a href="#片段着色器（Fragment-Shader）" class="headerlink" title="片段着色器（Fragment Shader）"></a>片段着色器（Fragment Shader）</h2><p>这是我们第二个也是最后一个创建出来用来渲染三角形的着色器。</p>
<p>它的作用是计算像素的颜色。</p>
<blockquote>
<p>在计算机图形中颜色被表示为有4个元素的数组：红色、绿色、蓝色和alpha(透明度)分量，通常缩写为RGBA。当在OpenGL或GLSL中定义一个颜色的时候，我们把颜色每个分量的强度设置在0.0到1.0之间。比如说我们设置红为1.0f，绿为1.0f，我们会得到两个颜色的混合色，即黄色。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;<span class="comment">//输出变量是一个有四个分量的变量。这里使用out声明变量。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = <span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);<span class="comment">//赋值FragColor,其中,第四个分量代表了透明度,1.0f为完全不透明.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后编译片段着色器,是一样的方法.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *fragmentShaderSource = <span class="string">&quot;#version 330 core</span></span><br><span class="line"><span class="string">out vec4 FragColor;//输出变量是一个有四个分量的变量。这里使用out声明变量。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);//赋值FragColor,其中,第四个分量代表了透明度,1.0f为完全不透明.</span></span><br><span class="line"><span class="string">&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> fragmentShader;</span><br><span class="line">fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader,<span class="number">1</span>,&amp;fragmentShaderSource,<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">glCompliesShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<p>之后的事情就是把两个着色器对象连接到着色器程序(ShaderProgram)上</p>
<h2 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h2><p>Shader Profram Object 是多个着色器合并之后最终连接完成的版本. 如果要使用刚才我们编译的两个着色器,我们需要把他们link为一个Shader Program Object,然后在渲染对象的时候激活这个Shader Program,这样我们才可以在发送渲染调用的时候调用我们编译的着色器.</p>
<p>创建着色器程序对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> shaderProgram;</span><br><span class="line">shaderProgram = <span class="built_in">glCreateProgram</span>();</span><br></pre></td></tr></table></figure>

<p>然后把着色器附加到程序对象上,在连接他们.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram,vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(shaderProgram,fragmentShader);</span><br><span class="line"><span class="built_in">glLinkProgram</span>(shaderProgram);</span><br></pre></td></tr></table></figure>

<p>然后是激活对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);<span class="comment">//在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。</span></span><br></pre></td></tr></table></figure>

<p>记得删除着色器对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在,我们已经把输入顶点数据发送给了GPU,并指示了GPU如何在顶点和片段着色器中处理它.</p>
<p>还差最后一步,OpenGL还不知道该如何解释内存中的顶点数据,以及他该如何将顶点数据链接到顶点着色器的属性上.</p>
<h2 id="链接顶点属性-设置顶点属性指针"><a href="#链接顶点属性-设置顶点属性指针" class="headerlink" title="链接顶点属性(设置顶点属性指针)"></a>链接顶点属性(设置顶点属性指针)</h2><p>顶点着色器允许我们以任意的形式,来输入顶点属性.</p>
<p>这意味着我们需要手动的指定我们输入的数据是以怎样的形式来存储的. 所以在渲染开始前,我们必须指定OpenGL来如何解释顶点数据.</p>
<blockquote>
<p>我们用一个数组来传递3个3d坐标作为管线的初始输入,这表示了一个三角形,这个数组就叫做顶点数据(Vertex Data),顶点数据是一系列顶点的集合.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们希望这个数组被这样解释:</p>
<ul>
<li>我们的顶点数据只存储位置(Position) 这一属性,储存的数据类型是占四个字节的浮点值.</li>
<li>每个位置包含三个这样的值.</li>
<li>在这三个值之间没空隙,他们在数组中是紧密排列(Tightly Packed)</li>
<li>数据中第一个值在缓冲开始的位置.</li>
</ul>
<p>为此,我们需要函数glVertexAtttribPointer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>,<span class="number">3</span>,GL_FLOAT,GL_FALSE,<span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>),(<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>它的参数比较多,我们逐一介绍</p>
<ul>
<li>第一个是我们要指定的顶点属性,我们在顶点着色器中用layout(location &#x3D; 0)定义了position顶点属性的Location,它把顶点属性的位置值设置为0.</li>
<li>第二个参数指定顶点属性的大小,这里的顶点属性是一个vec3,它由3个值组成,所以大小是3.</li>
<li>第三个参数是我们的数据类型,这里使用的是GLSL中的float类型,GL_FLOAT</li>
<li>第四个参数定义我们是否希望参数被标准化(Normalize),GL_TRUE和GL_FALSE</li>
<li>第五个参数为步长(Stride),它告诉OpenGL在连续的顶点属性组之间的间隔,即下一个顶点的属性在3个float之后,所以步长我们设置为3 * sizeof(float)</li>
<li>第六个参数要求的类型是void*,所以我们使用强制类型转换,他表示的是数据在缓冲中起始位置的偏移量(Offset),由于我们的数据在开头,所以是0.</li>
</ul>
<p>现在我们定义好了OpenGL是如何解释顶点数据的,现在我们应该使用glEnableVertexAttribArray,以顶点属性的位置值作为参数,启用顶点属性.</p>
<h2 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h2><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。</p>
<p>一个顶点数组对象会储存这些内容</p>
<ul>
<li>glEnableVertexAttribArray和glDisableVertexAttribArray的调用</li>
<li>通过glVertexAttribPointer设置的顶点属性配置</li>
<li>通过glVertexAttribPointer调用与顶点属性关联的VBO</li>
</ul>
<h3 id="使用顶点数组对象"><a href="#使用顶点数组对象" class="headerlink" title="使用顶点数组对象"></a>使用顶点数组对象</h3><p>创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> VAO;</span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure>
<p>使用glBindVertexArray绑定VAO,从绑定之后起,我们应该绑定和配置对应的VBO和属性指针,之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 绑定VAO</span></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), (<span class="type">void</span>*)<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ..:: 绘制代码（渲染循环中） :: ..</span></span><br><span class="line"><span class="comment">// 4. 绘制物体</span></span><br><span class="line"><span class="built_in">glUseProgram</span>(shaderProgram);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(VAO);</span><br><span class="line"><span class="built_in">someOpenGLFunctionThatDrawsOurTriangle</span>();</span><br></pre></td></tr></table></figure>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>自此,我们的渲染管线就设置好了:一个储存了我们顶点属性配置和应使用的VBO的顶点数组对象。一般当你打算绘制多个物体时，你首先要生成&#x2F;配置所有的VAO,(和必须的VBO及属性指针) 然后储存它们供后面使用。当我们打算绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。&#96;</p>
<p>这篇是learningOpenGL第二篇——你好三角形的学习笔记,但是离画出三角形还差一步,但是在迈出着最后一步的前,我们还需要理清楚我们已经学习过的一些概念.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/03/02/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/" rel="next" title="OpenGL学习笔记(1)">
                <i class="fa fa-chevron-left"></i> OpenGL学习笔记(1)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/03/16/OpenGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/" rel="prev" title="OpenGL学习笔记-3">
                OpenGL学习笔记-3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF-Graphics-Pipeline"><span class="nav-number">2.</span> <span class="nav-text">一.图形渲染管线(Graphics Pipeline)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%B6-%E9%A1%B6%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.</span> <span class="nav-text">零.顶点数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8-Vertex-Shader"><span class="nav-number">2.2.</span> <span class="nav-text">一.顶点着色器(Vertex Shader)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-%E5%9B%BE%E5%85%83%E8%A3%85%E9%85%8D-Primitive-Assembly"><span class="nav-number">2.3.</span> <span class="nav-text">二.图元装配(Primitive Assembly)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">三.几何着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="nav-number">2.5.</span> <span class="nav-text">四.光栅化阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">五.片段着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%B7%B7%E5%90%88%E9%98%B6%E6%AE%B5"><span class="nav-number">2.7.</span> <span class="nav-text">六.测试与混合阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88%E8%BE%93%E5%85%A5%E9%A1%B6%E7%82%B9%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">二.顶点着色器（输入顶点）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">3.1.</span> <span class="nav-text">创建顶点着色器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%9D%80%E8%89%B2%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">编译着色器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%87%E6%AE%B5%E7%9D%80%E8%89%B2%E5%99%A8%EF%BC%88Fragment-Shader%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">片段着色器（Fragment Shader）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9D%80%E8%89%B2%E5%99%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">着色器程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7-%E8%AE%BE%E7%BD%AE%E9%A1%B6%E7%82%B9%E5%B1%9E%E6%80%A7%E6%8C%87%E9%92%88"><span class="nav-number">6.</span> <span class="nav-text">链接顶点属性(设置顶点属性指针)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">顶点数组对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.</span> <span class="nav-text">使用顶点数组对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LeingBai</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
